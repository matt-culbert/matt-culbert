---
layout: post
title: Browser Password Safes
date: '2022-01-01T08:27:00.001-08:00'
author: Matt C
tags: 
modified_time: '2022-04-22T05:15:16.054-07:00'
thumbnail: https://blogger.googleusercontent.com/img/a/AVvXsEhWo8IraaamMiXQAj6koHsweRjbjGwOZtCuajWlhzFRbOuNbEfcIiFOt4_d4nc6VELNxWq6GW2ixHW_7VLJkjb059AhSLaAwLpXxH9ZrWK4EdFBvIDNUh7sVUKk6MrLoazgqh1b9PyQUXRkaomAv7w5yIUOekQhWOPbIVY47gzimljSq1cyWuB3L6e41w=s72-c
blogger_id: tag:blogger.com,1999:blog-8951407132095927802.post-2329473581475791925
blogger_orig_url: https://cr.culbertreport.com/2022/01/browser-password-safes.html
---

<h2 style="text-align: left;">&nbsp;How Safe Are They?</h2><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>I wanted to talk briefly about this as a lot of people don't believe browsers have strong password safes, that they can be retrieved in plaintext far easier than something like KeePass could, and that you're essentially giving away your passwords if there's ever a browser attack that lets bad actors steal files.</p><h3 style="text-align: left;">How does Firefox store passwords?</h3><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; L</span>et's check out Firefox. Firefox stores passwords in two files <a href="https://support.mozilla.org/en-US/kb/profiles-where-firefox-stores-user-data" rel="nofollow" target="_blank">according to their documentation.</a> That is the <span style="font-family: courier;">key4.db</span> file and the <span style="font-family: courier;">logins.json</span> file. The logins file contains a list of encrypted usernames and encrypted passwords along with the url they correspond to and some other details like time created and time last used. The encryption of the details is done with an AES-256-GCM cipher, according to <a href="https://blog.mozilla.org/en/products/firefox/password-security-features/" rel="nofollow" target="_blank">this Firefox update from 2019</a>. </p><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>AES-256 is a tried and trusted format that is regarded as quantum resistant. Grover's algorithm will only reduce symmetric key algorithms by half their strength as opposed to asymmetric algorithms which get destroyed entirely by Shor. So AES-256 goes down to 128 - which is still relatively secure. <br /></p><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Before we get into some math, let's take a brief moment to review. GCM is an authenticated encryption mode of operation. It takes a key, unique IV, data to be processed with only the authentication, and data to be both processed with both authentication and encryption. It outputs the encrypted data of part 4 and an authentication TAG. The TAG is used to to verify that the encrypted data or associated data has not been tampered with. AES uses GCM so as to to get better overall performance as compared to  CBC since CBC cannot run in parallel. With GCM, each block is  conceptualized and encrypted with AES in parallel. AES-GCM is known as an AEAD form of encryption. This means that it simultaneously assures both the confidentiality and authenticity of the data. A common attack on AES-GCM is<a href="https://www.usenix.org/sites/default/files/conference/protected-files/woot16_slides_bock.pdf" rel="nofollow" target="_blank"> message forgery given a reused nonce</a>, and this is called the<a href="https://github.com/ashutosh1206/Crypton/blob/master/Authenticated-Encryption/AES-GCM/Attack-Forbidden/README.md" rel="nofollow" target="_blank"> forbidden-attack</a>.&nbsp;</p><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Here's a quick example from the link, math courtesy of ashutosh1206. Take message g1, encrypted using g<sub>1</sub>(X) = C<sub>1,1</sub>X<sup>2</sup> + L<sub>1</sub>X + S and message g2 encrypted the same way, g<sub>2</sub>(X) = C<sub>2,1</sub>X<sup>2</sup> + L<sub>2</sub>X + S. L = len(A) || len(C) where A is the associated message (recall this from our GCM review?) and C is the ciphertext. S is our nonce value and, since each message uses the same nonce, the S values will be the same. The above polynomials cannot be solved without first removing S from them. Since we know that g<sub>1</sub>(H) = T (H is the authentication key and T is the authentication tag which includes the nonce value (S) in it), we can add T to both equations and then add the two polynomials together. Doing so, we get f(X) = (C<sub>1,1</sub>+C<sub>2,1</sub>)X<sup>2</sup> + (L<sub>1</sub> + L<sub>2</sub>)X + (T<sub>1</sub> + T<sub>2</sub>) and solving this quadratic equation gives all possible values of H, which we can then use to generate new and valid authentication tags and decrypt past data with.<br /></p><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Looking further at Firefox's implementation they, to the best of my knowledge, follow <a href="https://datatracker.ietf.org/doc/html/rfc7714" rel="nofollow" target="_blank">the RFC for AES-GCM</a> so they don't use repeating nonce/IV values. <span></span>Given this, attacking the implementation of encryption is impractical. </p><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Moving onto other vectors, we can take a look inside <span style="font-family: courier;">key4.db</span> which gives us two tables. </p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEhWo8IraaamMiXQAj6koHsweRjbjGwOZtCuajWlhzFRbOuNbEfcIiFOt4_d4nc6VELNxWq6GW2ixHW_7VLJkjb059AhSLaAwLpXxH9ZrWK4EdFBvIDNUh7sVUKk6MrLoazgqh1b9PyQUXRkaomAv7w5yIUOekQhWOPbIVY47gzimljSq1cyWuB3L6e41w=s279" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="103" data-original-width="279" height="103" src="https://blogger.googleusercontent.com/img/a/AVvXsEhWo8IraaamMiXQAj6koHsweRjbjGwOZtCuajWlhzFRbOuNbEfcIiFOt4_d4nc6VELNxWq6GW2ixHW_7VLJkjb059AhSLaAwLpXxH9ZrWK4EdFBvIDNUh7sVUKk6MrLoazgqh1b9PyQUXRkaomAv7w5yIUOekQhWOPbIVY47gzimljSq1cyWuB3L6e41w" width="279" /></a></div><br /><span>&nbsp;&nbsp; &nbsp;</span>The first is meta data and yields us two rows and columns. For the "password" row, one column is for the salt and the other is for the ASN.1, which just stands  for Abstract Syntax Notation 1. We'll need this for analyzing the data in the next table, nssPrivate, which  holds our master key.&nbsp;<div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEgBGUhsQn_Jame6F65Tzkbf8pYetkwDDq8EINS45ERGu8AG1P949Cor5aomnQDrNV4WQTsBPD6zOEyj8WFghYGiOGqVUesMQOgsAdDVkkVmX-XE-8ZBaKndnNHvL9NQT-uSZbVBY8JXLLG2HF1S5hpLwZYTjJqTHj4oxam_2Y7COYbYO46LaI8Cbvl-eQ=s592" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="78" data-original-width="592" height="63" src="https://blogger.googleusercontent.com/img/a/AVvXsEgBGUhsQn_Jame6F65Tzkbf8pYetkwDDq8EINS45ERGu8AG1P949Cor5aomnQDrNV4WQTsBPD6zOEyj8WFghYGiOGqVUesMQOgsAdDVkkVmX-XE-8ZBaKndnNHvL9NQT-uSZbVBY8JXLLG2HF1S5hpLwZYTjJqTHj4oxam_2Y7COYbYO46LaI8Cbvl-eQ=w482-h63" width="482" /></a></div><p></p><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; nssPrivate </span>has a ton of columns and each has  one row. Inside a11, we can find the master key used for decrypting the  rest of the data in <span style="font-family: courier;">logins.json</span> and which the tools we'll look at below automate  extracting. One way or another, each of these tools uses the salt and ASN.1 to format and retrieve the key value in a11 row[0] and uses this to decrypt the information seen in <span style="font-family: courier;">logins.json</span>.<br /></p><h3 style="text-align: left;">What tools are there to dump this information?</h3><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>There's a couple of tools like Dumpzilla and firefox_decrypt.py. Dumpzilla doesn't work anymore because it requires the <span style="font-family: courier;">signons.sqlite</span> file, which is no longer used. Ah, but firefox_decrypt.py also looks at the <span style="font-family: courier;">logins.json</span> file! If we run this on the <span style="font-family: courier;">logins.json</span> file alongside the <span style="font-family: courier;">key4.db</span>, and there is no master password set, we get back the passwords stored. But if a master password is set, there's no bruteforce functionality and the program fails.&nbsp;</p><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>A lot of tools try to primarily use Firefox's NSS library - which stands for simply Network Security Services. But one tool, <a href="https://github.com/lclevy/firepwd" rel="nofollow" target="_blank">firepwd</a>, uses none of that and does it all their own way. So props to them for doing a custom implementation.&nbsp;</p><h3 style="text-align: left;">What about KeePass?</h3><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span><a href="https://keepass.info/help/base/security.html" rel="nofollow" target="_blank">Keepass is very forthcoming</a> about how they secure your information. In 2.x versions, you get the option of AES or ChaCha20, both with 256 bit key sizes. AES is much more commonly seen than ChaCha20 so out of the two, let's check out ChaCha.</p><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>ChaCha20 is the successor to Salsa20. It's been adopted by Google as the defacto encryption scheme for their QUIC protocol and KeePass uses it in conjunction with CBC and HMAC-SHA-256 to ensure the datas' authenticity and integrity. This has the drawback though of being slow, which is why TLS has moved to ChaCha20-Poly1305. In something like a password safe though this slowness would be negligible as you only have to enter your password once to open up the safe. You're not doing repeated encryption operations thousands of times a second, it's only one, so normal users will never experience this. This could affect attackers though who trying to brute-force the master password. What will also affect attackers is KeePass' option to use Argon2 for the KDF. This function has resistance against GPU and ASIC attacks built into it through increased RAM and CPU costs which makes it harder to derive a valid key without knowing the password. The use of HAMC-SHA-256 to provide authentication is a move to prevent chosen-ciphertext attacks. <a href="https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac" rel="nofollow" target="_blank">This method is called encrypt-then</a><a href="https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac" rel="nofollow" target="_blank">-MAC </a>and allows the decryptor to check the message authentication code before they decrypt the message. If the MAC isn't valid, no decryption occurs. The combination of a slow encryption scheme through CBC, using Argon2 for a KDF, and hashing with HMAC-SHA-256 seems like a very strong approach to dissuade brute-forcing and oracle attacks.&nbsp;</p><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Overall, KeePass has very strong encryption and does a great job at protecting their users. I do wish that Argon2 was the default, but regardless attacking it is impractical. There are more things they do to protect user information that I haven't covered in this portion, like their secure desktop and in memory encryption, so read their full write up if you would like additional details.</p><h3 style="text-align: left;">What tools are there to dump KeePass kdbx files?</h3><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>None. KeePass requires a master password by default so is not susceptible to the same attack that Firefox is.<br /></p><h3 style="text-align: left;">How do they compare?</h3><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>If you set a master password in Firefox then no one will be able to retrieve your passwords except for those with that master key. The encryption chosen is as good as other desktop based password safes. Yes, without a master password set, Firefoxs database can be retrieved and information stolen trivially. But if you take one moment to setup a password, then you foil the attackers. Some may be wondering "What about Chrome?" Well Chrome secures your safe with your Windows session making it trivial for an attacker to read it if you're logged in.<br /></p>