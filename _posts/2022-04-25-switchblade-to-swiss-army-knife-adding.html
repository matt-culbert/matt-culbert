---
layout: post
title: 'Switchblade To Swiss Army Knife: Expanding The Toolset With Python'
date: '2022-04-25T10:41:00.002-07:00'
author: Matt C
tags: 
modified_time: '2022-04-28T05:46:14.435-07:00'
thumbnail: https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhtTxvaZh8tPYrtRls10jOyrel6k-mQDfkGPW7GIe7dYp6Z-5oeUA-xP_sIwKtxG3vwzYQDPfVk72oNNyQrI8rK_gtY_JWDkmBbIOG_hI01jHR_nSU-lWRyvBEzWwC9ZmLrni_qn28gW7tp_-6BybDu_LxQ1HOxpRepkKt2BIvOQ5cFGkS33EZCv1gJ1A/s72-w607-c-h159/fully%20usable%20beacon.png
blogger_id: tag:blogger.com,1999:blog-8951407132095927802.post-2950386095642929694
blogger_orig_url: https://cr.culbertreport.com/2022/04/switchblade-to-swiss-army-knife-adding.html
---

<h2 style="text-align: left;"><span><span>Intro <br /></span></span></h2><p><span><span>&nbsp;&nbsp; &nbsp;</span>A while ago I posted about Switchblade. This was a C2 technique that utilized mutual TLS to authenticate beacons that were compromised and separate them out from other traffic. I won't rehash it too much but it was a cool (in my opinion) way to use Nginx to authenticate beacons with an unusual method and would be considered zero trust since the beacon authenticated to the server and the server authenticated to the beacon.</span></p><p><span><span>&nbsp;&nbsp;&nbsp; </span>Since then, some stuff has changed and some stuff has been updated.<a href="https://github.com/matt-culbert/Switchblade/blob/main/beacon.py" rel="nofollow" target="_blank"> Find the details here</a>. Mainly, things could be done easier if the beacon did away with just a simple shell. So the beacon was changed to perform a GET request to the C2 which would have some response options. You can download a file or upload a file, you can inject a DLL into a process, or you can run a command such as cmd.exe or notepad.exe or calc.exe. Limitless potential!<br /></span></p><p><span></span><span></span></p><div class="separator" style="clear: both; text-align: center;"><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhtTxvaZh8tPYrtRls10jOyrel6k-mQDfkGPW7GIe7dYp6Z-5oeUA-xP_sIwKtxG3vwzYQDPfVk72oNNyQrI8rK_gtY_JWDkmBbIOG_hI01jHR_nSU-lWRyvBEzWwC9ZmLrni_qn28gW7tp_-6BybDu_LxQ1HOxpRepkKt2BIvOQ5cFGkS33EZCv1gJ1A/s625/fully%20usable%20beacon.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="164" data-original-width="625" height="159" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhtTxvaZh8tPYrtRls10jOyrel6k-mQDfkGPW7GIe7dYp6Z-5oeUA-xP_sIwKtxG3vwzYQDPfVk72oNNyQrI8rK_gtY_JWDkmBbIOG_hI01jHR_nSU-lWRyvBEzWwC9ZmLrni_qn28gW7tp_-6BybDu_LxQ1HOxpRepkKt2BIvOQ5cFGkS33EZCv1gJ1A/w607-h159/fully%20usable%20beacon.png" width="607" /></a></span></div><p><span><span>&nbsp;<span>&nbsp;&nbsp; </span>Let's review the code that's driving this.</span></span></p><h2 style="text-align: left;"><span><span><span>The Code </span></span></span></h2><h3 style="text-align: left;"><span><span><span>DLL Injection</span></span></span><span><span><span>&nbsp; <br /></span></span></span></h3><p><span><span><span><span><span>&nbsp;&nbsp;&nbsp; </span>DLL injection is somewhat confusing to a lot of people. They can be used to do a lot of things, but the main purpose is to manipulate  programs to change how they execute. For example, KeyFarce is a DLL to  dump the unlocked contents of a KeePass database. The code used in the beacon for DLL injection was taken from</span></span></span></span><span><span><span><span><span><span> Grayhat Python and slightly adapted for our needs.</span></span> </span></span></span></span></p><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjw-b_9hVVZnWSxpj11g0bgFSycIRMaWkVjgz01oC2qe40i4LlYG8rbrZcJxFV4N1gf8GhAqGeb8YNV54OWCWYnpx9uum6_lYQ8LmYsE2X-nPFn9TxlOlqaig7Ep0qk0DkxE9TO1xBmFkWkvmWQyMGHTR4GABCkyKdK1wtiJYzsYPd_pdzQ28Bthc9X9Q/s836/dll_injection.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="769" data-original-width="836" height="549" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjw-b_9hVVZnWSxpj11g0bgFSycIRMaWkVjgz01oC2qe40i4LlYG8rbrZcJxFV4N1gf8GhAqGeb8YNV54OWCWYnpx9uum6_lYQ8LmYsE2X-nPFn9TxlOlqaig7Ep0qk0DkxE9TO1xBmFkWkvmWQyMGHTR4GABCkyKdK1wtiJYzsYPd_pdzQ28Bthc9X9Q/w598-h549/dll_injection.png" width="598" /></a></div><p><span><span><br /> </span><span>&nbsp;&nbsp;&nbsp; </span>The only change that we made to the original was that we start a new process and get it's PID instead of injecting into our own main process. The idea behind this is that if injecting the DLL causes the process to crash, at least our beacon won't crash.</span></p><p><span><span>&nbsp;&nbsp;&nbsp; </span>Some may be wondering what these flags set at the start of the function are. More can be found in <a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants" rel="nofollow" target="_blank">this Microsoft documentation</a>, but the summary is that PAGE_READWRITE allows us to write to this section of "pages" and pages can be thought of as a virtual section of memory. Then PROCESS_ALL_ACCESS gives you rights to the whole process. Finally, the way the VIRTUAL_MEM flag is set allows us to reserve and commit a space of virtual memory in one go.</span></p><p><span><span>&nbsp;&nbsp;&nbsp; </span>This function is called with:</span></p><p><span><span>&nbsp;&nbsp;&nbsp; </span><span style="font-family: courier;">inject;{dll name}; null</span><br /></span></p><h3 style="text-align: left;"><span>Command Execution<br /></span></h3><p><span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span><span>&nbsp;&nbsp;&nbsp; </span>Executing commands  on another host is the most basic principle of a beacon. We need this  functionality to enumerate the domain, determine our IP, move files  around, add users, etc.</span></p><p><span></span></p><div class="separator" style="clear: both; text-align: center;"><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhCfEy_AFSHhw-O0ME79nBWX4CplgP7MknHqB_Lk-jHPoKvmoRmLwPJlBGmKSFT6CGrNE1RX9qel7R-xryFcaVY9js5cbP29MNKC0I7tXGUiO05U0XjdOAyPCcvEU_--h3z-GX6lZaQXGPxRJcOSWdur46tPSK3auLbhd8pTrY2dRfE7Al7dUCP0v8OjA/s936/cmdexe.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="241" data-original-width="936" height="155" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhCfEy_AFSHhw-O0ME79nBWX4CplgP7MknHqB_Lk-jHPoKvmoRmLwPJlBGmKSFT6CGrNE1RX9qel7R-xryFcaVY9js5cbP29MNKC0I7tXGUiO05U0XjdOAyPCcvEU_--h3z-GX6lZaQXGPxRJcOSWdur46tPSK3auLbhd8pTrY2dRfE7Al7dUCP0v8OjA/w605-h155/cmdexe.png" width="605" /></a></span></div><p></p><p><span><span><span>&nbsp;&nbsp; &nbsp;</span></span></span><span><span><span> Subprocess was chosen over  Os.System because it  executes commands in the context of a new process which makes some  detection more challenging. Os.System just forks a new child process for  each command  making it much easier to trace back the parent calling. This can be seen  if you look in your EDR at the execution chain comparing Os.System to  subprocess. Os.System can be traced back to Python calling it while  subprocess only shows that the command was run.</span></span></span></p><div class="separator" style="clear: both; text-align: center;"><span><span><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEivSgLPCQxJxzRw0MklckZ5itkfdfFoVexDLIuSRK_6ZySVvxIOJUh9hSLjkLeD6dBH10XMfmSLL6kmZ-z5S3bqLQlW3dpZdocuFXEQFUqd5EphwRRUXsxPq9h6Uw4h70W0dMqwEkBRDCXjBdlxwb4Pft6NeRAk3p_iH1wwpY5e4t1ywpjfHXt0sPMhrg/s703/ossystem-compare.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="117" data-original-width="703" height="118" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEivSgLPCQxJxzRw0MklckZ5itkfdfFoVexDLIuSRK_6ZySVvxIOJUh9hSLjkLeD6dBH10XMfmSLL6kmZ-z5S3bqLQlW3dpZdocuFXEQFUqd5EphwRRUXsxPq9h6Uw4h70W0dMqwEkBRDCXjBdlxwb4Pft6NeRAk3p_iH1wwpY5e4t1ywpjfHXt0sPMhrg/w712-h118/ossystem-compare.png" width="712" /></a></span></span></span></div><span><span></span></span><p></p><p><span><span><span>&nbsp;&nbsp; &nbsp;</span>The original intent with using subprocess was to use the DETACHED_PROCESS flag which makes our new process not inherit the parents console. The idea was that this would then start a new process which would not have a parent. This can be seen below.</span></span></p><div class="separator" style="clear: both; text-align: center;"><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjMYykzZdoohp5jmRAseaCPJH7KcRX9PQX7FFIrJ8IA8t54SOILvgXRiVcL5Sh865xAS-jgU585JE2rETBA6YqDgCp-IV25nCPNiybr4swY-DNB3wf34h9rATRDZ4XTcrTZP2Rdabnzf49Ws2yi6q0cAPXNSJEkftxk_wgBeSexSwV69AZ95qjon5rr4w/s574/no%20parent%20process.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="574" data-original-width="446" height="515" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjMYykzZdoohp5jmRAseaCPJH7KcRX9PQX7FFIrJ8IA8t54SOILvgXRiVcL5Sh865xAS-jgU585JE2rETBA6YqDgCp-IV25nCPNiybr4swY-DNB3wf34h9rATRDZ4XTcrTZP2Rdabnzf49Ws2yi6q0cAPXNSJEkftxk_wgBeSexSwV69AZ95qjon5rr4w/w401-h515/no%20parent%20process.png" width="401" /></a></span></div><span><span></span></span><p></p><p><span><span><span>&nbsp;&nbsp; &nbsp;</span>The parent is defined as Non-existent process. Cool right? Using the OS library cannot accomplish anything similar to this as far as I'm aware. The DETACHED_PROCESS flag causes issues though when issuing commands like "ipaddress" or "whoami" so the final version we see here has that removed.&nbsp;</span></span></p><p><span><span><span>&nbsp;&nbsp;&nbsp; </span>Below is an example of our beacon running "pwd." The EDR was able to determine that the process "cmd.exe" had called it with the "/C" flag set, and if we scroll over we can see there is a parent process identifying our beacon.</span></span></p><p><span><span></span></span></p><div class="separator" style="clear: both; text-align: center;"><span><span></span></span></div><div class="separator" style="clear: both; text-align: center;"><span><span></span></span></div><div class="separator" style="clear: both; text-align: center;"><span><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgGazQsTvv5Jg0IqEV2P5chTdBdJkkybFOZuQNr5kzjRM3NVLoWGBD5p1FRM-Wxa5sSGxjBqZYon6H-75XM8cdr9deX6F0DiMaVcOpYC-Id67H3pRWZ5kNMX1Q5z4kw4BNPrQwEl-MUl6pSmAL9ZjkSu6Cz9MD-hAvS9qw1FhHFQmCIjmsUU2bBQsb05w/s1091/pwd_trace.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="108" data-original-width="1091" height="76" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgGazQsTvv5Jg0IqEV2P5chTdBdJkkybFOZuQNr5kzjRM3NVLoWGBD5p1FRM-Wxa5sSGxjBqZYon6H-75XM8cdr9deX6F0DiMaVcOpYC-Id67H3pRWZ5kNMX1Q5z4kw4BNPrQwEl-MUl6pSmAL9ZjkSu6Cz9MD-hAvS9qw1FhHFQmCIjmsUU2bBQsb05w/w763-h76/pwd_trace.png" width="763" /></a></span></span></div><p><span><span><span>&nbsp; <span>&nbsp;&nbsp;&nbsp; </span>"pwd" however isn't an inbuilt tool on Windows. This was downloaded and added to the path. Running something like "whoami" produces very different results.</span></span></span></p><p><span><span><span></span></span></span></p><div class="separator" style="clear: both; text-align: center;"><span><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjKRJH8wrZI02q1jElouYkRrwU4gP0iOhQjHTTvAzg-IYgC5s32uABgUmsOJ5AkURCcDEkISxVdBhkNeAugtBTkTuGf_Qk2UXxPS7RfICIXCM-xysqYsKR6bAm5M9ZVGeKFgihsoB7suuTCOvNW2O1j-x8Abx9qeUvc8IDvhmrRjlXJMhgGasx7hvd6Sg/s1350/whoami_trace.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="424" data-original-width="1350" height="291" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjKRJH8wrZI02q1jElouYkRrwU4gP0iOhQjHTTvAzg-IYgC5s32uABgUmsOJ5AkURCcDEkISxVdBhkNeAugtBTkTuGf_Qk2UXxPS7RfICIXCM-xysqYsKR6bAm5M9ZVGeKFgihsoB7suuTCOvNW2O1j-x8Abx9qeUvc8IDvhmrRjlXJMhgGasx7hvd6Sg/w919-h291/whoami_trace.png" width="919" /></a></span></span></div><span><span><br /><span>&nbsp;&nbsp;&nbsp; </span>Unlike with the previous command, there is no parent calling process immediately linked, despite both examples being run the same way. The EDR does give us a parent PID, but we have to query that separately to find out what the parent truly was. To a quick glance, both of the "whoami" being run just look like a standard query being run by the user when one of them was actually run by our beacon.</span></span><p></p><p><span><span><span><span>&nbsp;&nbsp;&nbsp; </span>This command is called with:</span></span></span></p><p><span><span><span><span>&nbsp;&nbsp;&nbsp; </span><span style="font-family: courier;">cmd;{command to run}; null</span><br /></span></span></span></p><p></p><h3 style="text-align: left;"><span>File Download <br /></span></h3><p><span><span>&nbsp;&nbsp;&nbsp; </span>Downloading files  to a compromised end point is critical. We can add functionality by  downloading different DLLs like KeyFarce or we can update the beacon  with new features or signatures.</span></p><p><span></span></p><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhRAEeAFT0DApCdMdX5RcveUi93uD0yYQqWEL4EraNykppbfCR4ScWqJFUarOZD3N03HybCmV16KbDrQw7h8Rqp0IjmbjOlRWosuvwe9ThR8jSCjJTGmONsF-qyHi6FY-7LglMGm2_aLCB_j3v0HXxAR5PQu0IUzKNpgbLguw9Byjy1fyE9ATxGgtwWfw/s536/downloader.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="165" data-original-width="536" height="149" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhRAEeAFT0DApCdMdX5RcveUi93uD0yYQqWEL4EraNykppbfCR4ScWqJFUarOZD3N03HybCmV16KbDrQw7h8Rqp0IjmbjOlRWosuvwe9ThR8jSCjJTGmONsF-qyHi6FY-7LglMGm2_aLCB_j3v0HXxAR5PQu0IUzKNpgbLguw9Byjy1fyE9ATxGgtwWfw/w481-h149/downloader.png" width="481" /></a></span><br /></div><p><span><span>&nbsp;&nbsp;&nbsp; </span>Here, we just do a GET to the URL and then write the contents. We need to include the file extension for when we save it.</span></p><p><span><span>&nbsp;&nbsp;&nbsp; </span>This command is called with:</span></p><p><span><span>&nbsp;&nbsp; &nbsp;</span><span style="font-family: courier;">download;{url};{file extension}</span> <br /></span></p><h3 style="text-align: left;"><span>Uploading Files <br /></span></h3><p><span><span>&nbsp;&nbsp; Exfiltrating information  is also a critical function to have. Let's say you use KeyFarce to dump  the KeyPass contents, how are you planning on retrieving that?</span></span></p><div class="separator" style="clear: both; text-align: center;"></div><p></p><p><span></span></p><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFyQbYj-0QzEvFrJQt5Qqb9mnktCYiHAh2BnB0jKk0_3oWcjNLzeNL2Ut9GOxuJnHO-gj5gxmmLIDPjDIlnTRGjIcOikuIOYDSSZMnyjamSZVSR7khD7zxXWZ--I5lDPFom6EsEoV5cFpbz_8zUoQ7ggAxB4QACT22Gtg5hcgCPiuEif3ZJ4n7JaGfOw/s558/upload.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="161" data-original-width="558" height="142" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFyQbYj-0QzEvFrJQt5Qqb9mnktCYiHAh2BnB0jKk0_3oWcjNLzeNL2Ut9GOxuJnHO-gj5gxmmLIDPjDIlnTRGjIcOikuIOYDSSZMnyjamSZVSR7khD7zxXWZ--I5lDPFom6EsEoV5cFpbz_8zUoQ7ggAxB4QACT22Gtg5hcgCPiuEif3ZJ4n7JaGfOw/w494-h142/upload.png" width="494" /></a></span></div><p><span><span>&nbsp;&nbsp; &nbsp;</span>With this function, we get a file path and an upload URL, read it in binary format since that allows requests to determine the Content-length header, and then send it off to the URL.</span></p><p><span><span>&nbsp;&nbsp;&nbsp; </span>This command is called with:</span></p><p><span><span>&nbsp;&nbsp; &nbsp;</span> <span style="font-family: courier;">upload;{url};{file to upload]</span><br /></span></p><h3 style="text-align: left;"><span><span>The Brains<br /></span></span></h3><p></p><p></p><p><span><span>&nbsp;&nbsp;&nbsp; </span>Finally, the brains of the beacon.</span></p><p><span></span></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiKb-sBym6PWigOp_loB_s-oabmbdJD1Ld446xm7ctEPktnT37VmChhD1a9r6SU9khu3zUwC--OPXkeIjnGWVh2Z6UX2gxdKZ9bCRGzhmXDInajOWivwKxH7GxYOAjT-J7bePS3WAP7gsM5B-dAvPaKnuCs6VVxXIjQA2ZWXl7eSvSZk80koUYmU6fJ7A/s872/while_loop.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="482" data-original-width="872" height="287" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiKb-sBym6PWigOp_loB_s-oabmbdJD1Ld446xm7ctEPktnT37VmChhD1a9r6SU9khu3zUwC--OPXkeIjnGWVh2Z6UX2gxdKZ9bCRGzhmXDInajOWivwKxH7GxYOAjT-J7bePS3WAP7gsM5B-dAvPaKnuCs6VVxXIjQA2ZWXl7eSvSZk80koUYmU6fJ7A/w518-h287/while_loop.png" width="518" /></a></div><span><br /> <span>&nbsp;&nbsp;&nbsp; </span>The beacon does a GET to the C2 URL and splits the response on semicolons. There are four options pre built in. Cmd, inject, download, and upload. Each command calls their respective function that we reviewed above. For testing purposes, we are posting to httpbin.org/post which helps illustrate how the data is sent.</span><p></p><p><span><span>&nbsp;&nbsp;&nbsp; The mTLS is performed in the GET request every time it is used. We just need the client cert, key, and the CA cert file loaded either locally on Linux or into the cert chain on Windows.<br /></span></span></p><div class="separator" style="clear: both; text-align: center;"><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEinZaLv3DMg7ZzBCv7Tjub9wE5f9xQBbkz9qxwwlLTuRXsepNo6JsWETUfGkPB7IS8xdjdPlxfOVHliNxW7qCdN16kVVIRWxg6dxlUubAvrvTiqZr08BUxTCFawZXE5tycl6qAOAXqWQy5PEzTGru3mFl150weym4qALzSoHaJtMW6RmgSOJHPhje5Nkw/s844/mTLS.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="26" data-original-width="844" height="23" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEinZaLv3DMg7ZzBCv7Tjub9wE5f9xQBbkz9qxwwlLTuRXsepNo6JsWETUfGkPB7IS8xdjdPlxfOVHliNxW7qCdN16kVVIRWxg6dxlUubAvrvTiqZr08BUxTCFawZXE5tycl6qAOAXqWQy5PEzTGru3mFl150weym4qALzSoHaJtMW6RmgSOJHPhje5Nkw/w737-h23/mTLS.png" width="737" /></a></span></div><p><span></span></p><h3 style="text-align: left;"><span>Why GET Requests?</span></h3><p style="text-align: left;"><span><span>&nbsp;&nbsp;&nbsp; </span>A series of GET requests may not be the most graceful way of retrieving commands from our controller, but it does hide itself well among the typical internet traffic you might see. We have changed the user-agent as well to appear more like normal internet traffic, stealing the one FireFox uses. The overall beacon design is very flexible as well. If you don't care about getting responses back, you can just set up a simple web page for commands to be retrieved from and put Nginx in front of it to keep prying eyes away.<br /></span></p><p></p><h2 style="text-align: left;">Final Thoughts</h2><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>There are some issues that are caused by our use of ctypes here. Microsoft identifies this as malicious right away. Then, a lot of EDR vendors will pickup on the CreateRemoteThread flag that we use heavily in the DLL injection portions. VirtualAllocEx will also stand out to a lot of EDR tools but mainly when you allocate memory with read/write/execute permissions and that's never a good idea. What we've done here is allocate the memory with read/write and then we create a new&nbsp; thread with an entry point to the LoadLibrary function that then points to our DLL. Despite all this, this goes undetected by a fair amount of vendors on Virustotal which isn't too surprising to see. SentinelOne, Microsoft, and Elastic are top of the field when it comes to identifying new and emerging threats.<br /></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEipYArzpHTKcDqZoTU1I1_4mrnGjJr4mxiJCjJTHA3iObrVUbA9fmxQEpxqPErUvS3f6vHqtL8XQQbMx4xmuGElZN4QdjQ_wJY4TuuNNuQxLQIOQkumqopAHKsY6q1mQYESTWYuXqLhqPQn1PRWzV2KyB5d4R_22ECBaHCn-VZSPO6iWG16MM7mvhHaJw/s1329/detections.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="505" data-original-width="1329" height="332" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEipYArzpHTKcDqZoTU1I1_4mrnGjJr4mxiJCjJTHA3iObrVUbA9fmxQEpxqPErUvS3f6vHqtL8XQQbMx4xmuGElZN4QdjQ_wJY4TuuNNuQxLQIOQkumqopAHKsY6q1mQYESTWYuXqLhqPQn1PRWzV2KyB5d4R_22ECBaHCn-VZSPO6iWG16MM7mvhHaJw/w870-h332/detections.png" width="870" /></a></div><br /><br /><p></p><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; Making your own C2 is a lot of fun and there's a ton of learning that comes with it along the way. You have to address how to hide commands being run, how to exfiltrate information, and how deal with commands being fetched. I had played with Empire and Metasploit previously but had not delved into how they handle multiple compromised endpoints too much, so this was a fun opportunity to solve this problem on my own. There were roadblocks with features that should have been implemented, mainly process injection. It would have been nice to get this implemented but if you're going to use ctypes that much, you may as well just use C. It wasn't showcased here either, but handling multiple compromised endpoints is as simple as changing the URL each beacon checks into before compiling into an EXE.<br /></span></p><p><span><span>&nbsp;&nbsp; &nbsp;</span><br /></span></p><p></p>