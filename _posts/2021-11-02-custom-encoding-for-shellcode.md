---
layout: post
title: Custom Encoding For Shellcode
date: '2021-11-02T18:22:00.003-07:00'
author: Matt C
tags: 
modified_time: '2021-11-02T18:22:33.867-07:00'
thumbnail: https://blogger.googleusercontent.com/img/a/AVvXsEg9vMZ32DpubnkYblqcYnjfuAzYuUIVZ83kriDNmRdOxty2T56ejb-wlF8BXjUOYdbXBsyR3fgbfEPc98MCOPqyOCE0mc9G3bmbu_HhOn1WBXS6Jfujw7MZ5JIDavET4ke48xnOel2i_3Yhd9Obb2DCHfAqFj2wAkm14M8vFENEbyyQ2jM45NqebPRyFA=s72-w481-c-h179
blogger_id: tag:blogger.com,1999:blog-8951407132095927802.post-3945384526660517214
blogger_orig_url: https://cr.culbertreport.com/2021/11/custom-encoding-for-shellcode.html
---

<h3 style="text-align: left;">Tired of your payloads constantly getting detected? Tried MSFVenom and still have had no luck with making it past EDR?&nbsp;</h3><h3 style="text-align: left;">Then read on for to how to make your own encoder.</h3><h4 style="text-align: left;">Preface: <br /></h4><p style="text-align: left;">Before we get into the weeds, I have to <a href="https://www.ired.team/offensive-security/code-injection-process-injection/writing-custom-shellcode-encoders-and-decoders#the-encoder-itself">credit the project</a> that this was heavily based on by ired.team. It can be found by following the hyperlink. I took it one step further by combining it into one Windows based script and showing applications as well as analyzing the detection's.</p><h3 style="text-align: left;">Now onto the fun:</h3><p style="text-align: left;">The code for the project <a href="https://github.com/matt-culbert/OffSec/blob/main/encode.ps1" target="_blank">can be found here</a>. One should have familiarity with Powershell and hex while working through this. Knowledge of assembly isn't required, but things will make more sense with it. ired.team should be credited for heavily for all of this, but especially for commenting the assembly file, it helps a lot with understand it.</p><p style="text-align: left;">The first step is to encode our hex payload. For this we will use Powershell. We run through the hex encoded string and XOR it, add to it, and then XOR it again, before returning the new encoded string.<br /></p><p style="text-align: left;"></p><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEg9vMZ32DpubnkYblqcYnjfuAzYuUIVZ83kriDNmRdOxty2T56ejb-wlF8BXjUOYdbXBsyR3fgbfEPc98MCOPqyOCE0mc9G3bmbu_HhOn1WBXS6Jfujw7MZ5JIDavET4ke48xnOel2i_3Yhd9Obb2DCHfAqFj2wAkm14M8vFENEbyyQ2jM45NqebPRyFA=s1260" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="467" data-original-width="1260" height="179" src="https://blogger.googleusercontent.com/img/a/AVvXsEg9vMZ32DpubnkYblqcYnjfuAzYuUIVZ83kriDNmRdOxty2T56ejb-wlF8BXjUOYdbXBsyR3fgbfEPc98MCOPqyOCE0mc9G3bmbu_HhOn1WBXS6Jfujw7MZ5JIDavET4ke48xnOel2i_3Yhd9Obb2DCHfAqFj2wAkm14M8vFENEbyyQ2jM45NqebPRyFA=w481-h179" width="481" /></a></div><p>Running this returns our new encoded string and the size of it.&nbsp; <br /></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEhIf337s88lGMUmMJM1axdFFajBmlmVxdz3mQi2xvKG-EGd1N_CzUdZlhWPeNMh3s6OuTH3QBywzP1ArgWAVO8DmBfcd8WbWUFq_waMR1l6OCSaDdslCz0Rhy1Nm8smsZfhyjVAnNRyFf-Oy3F0n84iZtbUGCV37u06gPW2V5J9PCfEzFDq2iWPr4eaPw=s1202" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="133" data-original-width="1202" height="53" src="https://blogger.googleusercontent.com/img/a/AVvXsEhIf337s88lGMUmMJM1axdFFajBmlmVxdz3mQi2xvKG-EGd1N_CzUdZlhWPeNMh3s6OuTH3QBywzP1ArgWAVO8DmBfcd8WbWUFq_waMR1l6OCSaDdslCz0Rhy1Nm8smsZfhyjVAnNRyFf-Oy3F0n84iZtbUGCV37u06gPW2V5J9PCfEzFDq2iWPr4eaPw=w487-h53" width="487" /></a></div>The size is needed for our assembly to properly know how many bytes to process.<p></p><p style="text-align: left;">With the size and newly encoded shellcode, we can then move on to our assembly file.&nbsp;</p><p style="text-align: left;"></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjk52JZwXtZQTO2j_hQpLnHOQa1rj2zUIr-5Z1dlAa5YfmHJ_mrwo8b281R7zwcYi1hbuyE47pnRN94NAK6B4JanB-MOxRBkaSF2Z2ZzJTvl7M7Wo9WR0JFrGWxyIhvT0JG5ITI-p_AonWmtHzt662ZnK5YfgHlB5MVAtiSPZpEfwVPLDCQJWN2Rz9wFQ=s471" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="471" data-original-width="272" height="320" src="https://blogger.googleusercontent.com/img/a/AVvXsEjk52JZwXtZQTO2j_hQpLnHOQa1rj2zUIr-5Z1dlAa5YfmHJ_mrwo8b281R7zwcYi1hbuyE47pnRN94NAK6B4JanB-MOxRBkaSF2Z2ZzJTvl7M7Wo9WR0JFrGWxyIhvT0JG5ITI-p_AonWmtHzt662ZnK5YfgHlB5MVAtiSPZpEfwVPLDCQJWN2Rz9wFQ=s320" width="185" /></a></div><p>This is a quick assembly file that loops through our encoding scheme in reverse. The math operations happen in reverse of what we use in our encoding scheme because we want to generate instructions for undoing it. This way, when we compile our code, we get back the encoded shellcode as well as the assembly operations for decoding it. We can run it through nasm <i>nasm -f win64 .\decode.asm -o Decode</i> and examine the output in CFF Explorer. This looks like below. <br /></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEhIw0Um11BXXBqoDok3neZ-iuvTWA_9c_d8yw3l4UnuOkiMmeCe7_hDXssoZ7UMcNFzaOWPOFe9hDVH9gRxTFMXiAo0J0t3gBzd8tfOLW3M6jHyQjQ5d-A1Q-ESwvq1QWZadhMSALtPLRbToO-KR0ibqDD7jxxz6YAij97IcPlUgiblldFGXro00eaZ8A=s1203" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="751" data-original-width="1203" height="279" src="https://blogger.googleusercontent.com/img/a/AVvXsEhIw0Um11BXXBqoDok3neZ-iuvTWA_9c_d8yw3l4UnuOkiMmeCe7_hDXssoZ7UMcNFzaOWPOFe9hDVH9gRxTFMXiAo0J0t3gBzd8tfOLW3M6jHyQjQ5d-A1Q-ESwvq1QWZadhMSALtPLRbToO-KR0ibqDD7jxxz6YAij97IcPlUgiblldFGXro00eaZ8A=w446-h279" width="446" /></a><br /></div><p>The highlighted section starts at <i>EB 1E </i>and, you might notice, ends at the last character of our payload, <i>3F 20</i>. This blocks includes our decode scheme and our encoded payload. So when we load the payload into an application, it knows how to decode it as shown below. The encoded version is on the left and the decoded is on the right.<br /></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjakm7RxcOAaB0IcRX-Av_1F_RuNhNawvTJBFAHc0upv7RetH7QGzqzycHuadVbrA5-Gb1PxMyKpu9SHrpDbBTSH9pJ8CUSp6Ey1OXnoJxbRgZ9MnrBCL_i99cBGLvqVYf79yxVhwmolc1j91bqBIx96t9SB35P-1vTx4iVplSSaD26_P-D3WWyfag52w=s1655" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1020" data-original-width="1655" height="313" src="https://blogger.googleusercontent.com/img/a/AVvXsEjakm7RxcOAaB0IcRX-Av_1F_RuNhNawvTJBFAHc0upv7RetH7QGzqzycHuadVbrA5-Gb1PxMyKpu9SHrpDbBTSH9pJ8CUSp6Ey1OXnoJxbRgZ9MnrBCL_i99cBGLvqVYf79yxVhwmolc1j91bqBIx96t9SB35P-1vTx4iVplSSaD26_P-D3WWyfag52w=w509-h313" width="509" /></a></div><p></p><p></p><h3 style="text-align: left;">Applying what we've done:<br /></h3><p>With this shellcode, we can insert it into an application using something like <a href="https://github.com/ins1gn1a/Frampton">Frampton</a>.&nbsp; <br /></p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjzAvtWOxj4do5HMwhf4nTJ0bThfYfCHq5O-fBIQg3WniLX8k_-5TsNUK8yYTu8GntoeiBStX7WU4f2IMK-40MB3S3yKviG4ezFrdSpOEIRi1Abeg5JRjRt8G5xbZMiTDkuOOgd0ejaSARvZxSEhxt-sFdUthi2fup-n1ppC5_WzuNnsO5ULf5tmi6Ijg=s802" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="663" data-original-width="802" height="308" src="https://blogger.googleusercontent.com/img/a/AVvXsEjzAvtWOxj4do5HMwhf4nTJ0bThfYfCHq5O-fBIQg3WniLX8k_-5TsNUK8yYTu8GntoeiBStX7WU4f2IMK-40MB3S3yKviG4ezFrdSpOEIRi1Abeg5JRjRt8G5xbZMiTDkuOOgd0ejaSARvZxSEhxt-sFdUthi2fup-n1ppC5_WzuNnsO5ULf5tmi6Ijg=w372-h308" width="372" /></a></div><p>Frampton is a tool to insert shellcode into code caves within applications. Code caves are a whole different topic to get into but the long and short of it is that after compiling programs there's empty space left over. This space can be filled with our code that's either pointing to an external resource or by finding a cave large enough to fit our whole payload. Once Frampton finds and inserts into this code cave, it changes the execution point to start where our cave is filled, and works from there.&nbsp; <br /></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjS3TPmH7yDZRAgkD8zQwCyFxGPVAS0d4ab-6ERrqcicMbdstGm9In09W2ILvQGV15RSJQgEjJLG54cEbw5GAPnvXymT6Z1InZjGGfgblNNAOB2YgIYTFkfEtFWKlPLKLyoRgDYuu9tzWGf1km4phPikhq1-6PT84jk7oV2FG_w5Y3wtxMUZ4cu2nZM_g=s891" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="729" data-original-width="891" height="299" src="https://blogger.googleusercontent.com/img/a/AVvXsEjS3TPmH7yDZRAgkD8zQwCyFxGPVAS0d4ab-6ERrqcicMbdstGm9In09W2ILvQGV15RSJQgEjJLG54cEbw5GAPnvXymT6Z1InZjGGfgblNNAOB2YgIYTFkfEtFWKlPLKLyoRgDYuu9tzWGf1km4phPikhq1-6PT84jk7oV2FG_w5Y3wtxMUZ4cu2nZM_g=w364-h299" width="364" /></a><br /></div><p>It's not super elegant because we're not controlling where the code cave is, it makes file sections that are normally not executable now executable, and the application flow doesn't work as you might normally expect afterwards. Because the PE has a new entry point outside of the .text section, which is normally the only executable section of a file, AV has a higher chance of flagging it as malicious.&nbsp; <br /></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjuCc8GZcDFGJ1MtqZyLGVvcG46zqxiSgxKvnGjD5I3qpiCFEYfp5C1dNOSMX9FHpXCkI0oV6t783Ws141CDRXhFmWvLS1prPCHGI4j-tmwSdJY-MIMGI6A00esgrRf3_rawhCyhcp7TQ8Pw9nDBWPZl_kCYWELSnP2EmqaXyHfwJrfJYnUvFDPpuS2Nw=s1570" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="472" data-original-width="1570" height="111" src="https://blogger.googleusercontent.com/img/a/AVvXsEjuCc8GZcDFGJ1MtqZyLGVvcG46zqxiSgxKvnGjD5I3qpiCFEYfp5C1dNOSMX9FHpXCkI0oV6t783Ws141CDRXhFmWvLS1prPCHGI4j-tmwSdJY-MIMGI6A00esgrRf3_rawhCyhcp7TQ8Pw9nDBWPZl_kCYWELSnP2EmqaXyHfwJrfJYnUvFDPpuS2Nw=w369-h111" width="369" /></a></div><br /><h3>Analyzing detection:</h3><p style="text-align: left;">We've inserted our encoded shellcode into an application and made it executable. So what does the Virustotal detection look like?&nbsp;</p><p style="text-align: left;"></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEhV-IttCZbl8lWuXtZxm8yXrfWYCr8mcoNvy_aF5I4zfRHETfNdqyuV2h9MSHfqc8ydoAHrE-cBv8QBOvC2XAEc7lPdmdt2VhPOAbVpbRVy_txu5HueHhUAykOJwgo6kHOavqtt77COPBp-TivdWpG2c1E5hrfUa_Z1yObo3Xk-UwW2K2YKZ3WdhotVSQ=s1424" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="640" data-original-width="1424" height="204" src="https://blogger.googleusercontent.com/img/a/AVvXsEhV-IttCZbl8lWuXtZxm8yXrfWYCr8mcoNvy_aF5I4zfRHETfNdqyuV2h9MSHfqc8ydoAHrE-cBv8QBOvC2XAEc7lPdmdt2VhPOAbVpbRVy_txu5HueHhUAykOJwgo6kHOavqtt77COPBp-TivdWpG2c1E5hrfUa_Z1yObo3Xk-UwW2K2YKZ3WdhotVSQ=w452-h204" width="452" /></a></div><p><br />Just about all the vendors are detecting the invalid signature in PuTTY now since we've changed the file and the remaining vendors are detecting the unusual entry point. Compare this with the detection of the same payload encoded using Shikata Ga Nai. <br /></p><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEj-YRKbINOdGEdZCzOFaNFt37cOCNJ4yarhGryNCc4sgABICTQTaYSaYQXrYXINWcHNIrF5xZRLwpXzidVkmkyLb9dUUFSouO_iLzRq_72zBFIvwx38nRx815G6A-O-a5OPE7bwDaq1Z5ldL2mSIL-h1nLTiKpdjf6DSZuUZVaDUxjjnC7giyFi5CEjjA=s1286" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="601" data-original-width="1286" height="212" src="https://blogger.googleusercontent.com/img/a/AVvXsEj-YRKbINOdGEdZCzOFaNFt37cOCNJ4yarhGryNCc4sgABICTQTaYSaYQXrYXINWcHNIrF5xZRLwpXzidVkmkyLb9dUUFSouO_iLzRq_72zBFIvwx38nRx815G6A-O-a5OPE7bwDaq1Z5ldL2mSIL-h1nLTiKpdjf6DSZuUZVaDUxjjnC7giyFi5CEjjA=w453-h212" width="453" /></a></div><p>We can see a big jump in detections as well as some vendors identifying the specific encoding scheme used.<br /><br /></p><p></p><p></p><p></p>