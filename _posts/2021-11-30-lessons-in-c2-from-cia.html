---
layout: post
title: Lessons In C2 From The CIA
date: '2021-11-30T08:22:00.002-08:00'
author: Matt C
tags: 
modified_time: '2021-12-01T12:47:38.033-08:00'
thumbnail: https://blogger.googleusercontent.com/img/a/AVvXsEgx26sLKEIDIjxHjpBJlhn0-jfJ449ZHaan46ygweRNpeHEBVW-y9Q7173kY2aei_EvgYEcgHcs4EiaQRNVM8D3ZYdzlloPVnGToFNpmwAeL3j3Hnybjs8heBfJJtfIbHmhRGObLshV_USQ39HGgU611Cz8BvuIv8uNwDGWd1eeG8Vsv0k8pkTAHlVzgA=s72-w494-c-h272
blogger_id: tag:blogger.com,1999:blog-8951407132095927802.post-1374378154672041409
blogger_orig_url: https://cr.culbertreport.com/2021/11/lessons-in-c2-from-cia.html
---

<h2 style="text-align: left;">Intro</h2><p style="text-align: left;">I've always wanted to make my own C2 framework but have never really found the inspiration to, until I came across a post from Byt3bl33d3r talking about <a href="https://byt3bl33d3r.substack.com/p/taking-the-pain-out-of-c2-infrastructure-3c4" rel="nofollow" target="_blank">modernizing the CIA's C2 framework</a>. This was somehow the first time I had come across a paper regarding Switchblade and Hive and I wanted to try and set up a mock version for myself.<br /></p><h2 style="text-align: left;">A Quick Review Of mTLS</h2><p style="text-align: left;">Before getting into the gritty details of this, let's review/introduce mTLS. mTLS stands for mutual authentication TLS. This is often implemented in zero-trust environments so that the client knows the server is who they say they are and vice-versa. Where a server normally only presents its certificate to connecting clients and then completes connections, mTLS adds the extra step of the client presenting their certificate so that the server can then verify them. The CIA developed Switchblade to use mTLS to authenticate beacon requests to the C2 server and send everyone else to a fake cover site. It can be seen in the diagram below taken from the Vault 7 leaks.<br /></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEgx26sLKEIDIjxHjpBJlhn0-jfJ449ZHaan46ygweRNpeHEBVW-y9Q7173kY2aei_EvgYEcgHcs4EiaQRNVM8D3ZYdzlloPVnGToFNpmwAeL3j3Hnybjs8heBfJJtfIbHmhRGObLshV_USQ39HGgU611Cz8BvuIv8uNwDGWd1eeG8Vsv0k8pkTAHlVzgA=s896" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="492" data-original-width="896" height="272" src="https://blogger.googleusercontent.com/img/a/AVvXsEgx26sLKEIDIjxHjpBJlhn0-jfJ449ZHaan46ygweRNpeHEBVW-y9Q7173kY2aei_EvgYEcgHcs4EiaQRNVM8D3ZYdzlloPVnGToFNpmwAeL3j3Hnybjs8heBfJJtfIbHmhRGObLshV_USQ39HGgU611Cz8BvuIv8uNwDGWd1eeG8Vsv0k8pkTAHlVzgA=w494-h272" width="494" /></a></div><br /><p></p><h2 style="text-align: left;">How Can We Leverage This?</h2><p style="text-align: left;">I haven't seen a FOSS C2 framework specifically utilizing mTLS yet. There have been quite a few using HTTPS and that's fantastic, but it's always fun to take things one step further. In an engagement, when an analyst examines unusual traffic from workstations, forwarding those unauthenticated queries from them to something like google.com provides a minor level of credibility. Taking that further, you could even host your operations in the Google cloud so when they examine the IP it shows up as being owned by Google. This provides far more cover then returning a server error and sort of allows one to hide in plain sight.</p><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEh-IGcseu2eHiQN5Blc8AyH5a5-UKrVNZzNX0y9e71Lb5NvENneYFIeZP9O7XytzK3HB7wGAWasGN88FfZOoRoVhdg4hmeVYvCPy5-IKfYkcVrc8WTX323L44Bdx78CRmnwlM7iYuNEaKL6__xWaLFrucqc4EPHsE5TFX9gc2THllt1SH8I68rEccyG0Q=s1595" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="490" data-original-width="1595" height="158" src="https://blogger.googleusercontent.com/img/a/AVvXsEh-IGcseu2eHiQN5Blc8AyH5a5-UKrVNZzNX0y9e71Lb5NvENneYFIeZP9O7XytzK3HB7wGAWasGN88FfZOoRoVhdg4hmeVYvCPy5-IKfYkcVrc8WTX323L44Bdx78CRmnwlM7iYuNEaKL6__xWaLFrucqc4EPHsE5TFX9gc2THllt1SH8I68rEccyG0Q=w517-h158" width="517" /></a></div><p></p><h4 style="text-align: left;"><span style="font-weight: normal;">&nbsp;Now into the details of the project.</span><br /></h4><h4 style="text-align: left;">Generating certs&nbsp;</h4><p style="text-align: left;">It took me a little bit to figure out how to properly generate certs for mTLS that work well with our transparent proxy configuration until I came across <a href="https://medium.com/geekculture/mtls-with-nginx-and-nodejs-e3d0980ed950" rel="nofollow" target="_blank">this resource</a>. I recommend following along with what they have written as it works flawlessly. Just ensure that your CN name matches up with the server name you'll be routing to, otherwise you'll encounter errors.<br /></p><h4 style="text-align: left;">Nginx conf</h4><p>The config for Nginx goes into /etc/nginx/conf.d/ and can be found <a href="https://github.com/matt-culbert/OffSec/blob/main/Switchblade/nginx.conf" target="_blank">here</a>. There's nothing super fancy here, it's primarily the one leaked from the CIA and it uses an if statement to check the supplied certificates. If it fails, the client is transparently redirected to the cover site. We did add a few lines specifically that nginx documents as needed for facilitating websockets, but that's it. People familiar with nginx will notice that the websocket upgrade arguments are outside of where they should go according to documentation, but this was how it worked without errors and, while troubleshooting this, I noticed that CIA also had it setup this way.</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEhjZJOy5DnO7zRVAJs3C9GL1YCGzu6jODN3cL_7_mehep46jwJnHySMfJKVnNYzR-q_MsTuh45dnwz97YQfHBwURxQI68c2HD6t90C-Jdb1TP3u8FaF6NXcM7YBxsVv6VhYJE1PMby5jrBdxtn2MHHBDV7LIEMDqROvVRuuqqfQ9zlAk1GC4gZ9nyi3OA=s807" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="477" data-original-width="807" height="274" src="https://blogger.googleusercontent.com/img/a/AVvXsEhjZJOy5DnO7zRVAJs3C9GL1YCGzu6jODN3cL_7_mehep46jwJnHySMfJKVnNYzR-q_MsTuh45dnwz97YQfHBwURxQI68c2HD6t90C-Jdb1TP3u8FaF6NXcM7YBxsVv6VhYJE1PMby5jrBdxtn2MHHBDV7LIEMDqROvVRuuqqfQ9zlAk1GC4gZ9nyi3OA=w464-h274" width="464" /></a></div><p></p><h4 style="text-align: left;">Back-end server</h4><div style="text-align: left;">For the server, it started as a Node project that nginx uses in their <a href="https://www.nginx.com/blog/websocket-nginx/" rel="nofollow" target="_blank">example documentation</a> for websockets. A client connects and checks in with a simple "hello" and then the server fires off a response. After the client check in, they are appended to an array and logged. This has it's shortcomings. Only one client seems to be able to stay connected at a time so we need a better solution. Thankfully, Node is super popular and I <a href="https://medium.com/@willrigsbee/how-to-keep-track-of-clients-with-websockets-1a018c23bbfc" rel="nofollow" target="_blank">found someone</a> who was handling multiple websockets very quickly! Find this <a href="https://github.com/matt-culbert/OffSec/blob/main/Switchblade/server.js" rel="nofollow" target="_blank">here</a>.<br /></div><h4 style="text-align: left;">Client</h4><p style="text-align: left;">Python makes a fantastic test bed to get this up and running super quickly. Super quick might be a reach because the amount written on websockets and mTLS in Python is very sparse compared to other areas. But we're getting ahead of ourselves.&nbsp;</p><p style="text-align: left;">Before this, I should talk about what was tried and what failed. This started with doing web requests through Python to a back-end web server, with nginx routing it based off of certificates supplied or not. Which worked fine, the web requests were all routed correctly and they retrieved the page, but there was a hitch. This isn't an ideal solution in any way because the HTTP protocol is unidirectional and operates on a request response method. Once data is finished being sent, the connection is closed. Passing commands over GET requests is finicky and not very dynamic.&nbsp; <br /></p><p style="text-align: left;">I next turned to sockets. Sockets are fantastic but fall just short of the mark here because, with the nginx configuration, I was able to send HTTP GET requests but was not able to get a socket to communicate back and forth through this transparent proxy.<br /></p><p style="text-align: left;">What's the solution? Websockets. Nginx out of the box actually supports these really well and we can even see the CIA implementing the start of one in the example configuration leaked. Websockets big advantage is that they allow for bidirectional communication and they work easily with the transparent proxy.</p><p style="text-align: left;">Find the code <a href="https://github.com/matt-culbert/OffSec/blob/main/Switchblade/websocket.py" target="_blank">for this here</a>. For my example I smashed two projects together from <a href="https://github.com/matt-culbert/OffSec/blob/main/Switchblade/deprecated-client.py" target="_blank">here</a> and <a href="https://github.com/aaugustin/websockets/blob/34aaf6bcbbac62d8c605d5ba768709346ef87c6e/example/secure_client.py" target="_blank">here</a>. The interaction between the client and server looks like this.</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEhi_uSQ9LirnTgSqMCVIDlD4a-Xt6UfEk-m3HW0ui40PrQC9rJelDOHr1OEhQYL2VDcjP_znvM7djH8Ahb79KS0WVejZRqMFwolzo-7ZkcZllKvpH5KXHLHmDneD9bXvZl6t8-WZihDTCaaWBTow9X1yPSCbQYud4NZwO3SNkVdz0XP76oG7XxlMXXdCw=s444" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="173" data-original-width="444" height="125" src="https://blogger.googleusercontent.com/img/a/AVvXsEhi_uSQ9LirnTgSqMCVIDlD4a-Xt6UfEk-m3HW0ui40PrQC9rJelDOHr1OEhQYL2VDcjP_znvM7djH8Ahb79KS0WVejZRqMFwolzo-7ZkcZllKvpH5KXHLHmDneD9bXvZl6t8-WZihDTCaaWBTow9X1yPSCbQYud4NZwO3SNkVdz0XP76oG7XxlMXXdCw=s320" width="320" /></a></div><p></p><p style="text-align: left;">Update: We've got an interactive shell now!</p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjFWGMM_ZUEAhfZqOtUaVjycSq5brRsrttySRgb37VuC6S2uRKDkDlQzuctUaP3pHMudig_ImkmZ1gFcfGlIi3BdVBAKA3xsFQ4Hqjbbf5Z74zyNNsdUBagbWh6QVm96GvnHOoFh0FrQdTb7YFhqJ0AKGXaXwacnDtZhQ-vCKVsEmj3bnrEGGi8ZrHNuA=s614" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="597" data-original-width="614" height="361" src="https://blogger.googleusercontent.com/img/a/AVvXsEjFWGMM_ZUEAhfZqOtUaVjycSq5brRsrttySRgb37VuC6S2uRKDkDlQzuctUaP3pHMudig_ImkmZ1gFcfGlIi3BdVBAKA3xsFQ4Hqjbbf5Z74zyNNsdUBagbWh6QVm96GvnHOoFh0FrQdTb7YFhqJ0AKGXaXwacnDtZhQ-vCKVsEmj3bnrEGGi8ZrHNuA=w371-h361" width="371" /></a></div><p></p><h4 style="text-align: left;">Client in alternative languages<br /></h4><h4 style="text-align: left;"></h4><p style="text-align: left;">Alongside creating the Python client/server, I also wanted something which could more traditionally be compiled into an executable. We have a few candidates we can look at for this, I'm thinking Go or C#. Both languages are well documented, memory safe, and have very strong built in libraries. Unfortunately, I'm not super familiar with developing apps in either, so this will be an adventure. Expect more on this soon.<br /></p><h4 style="text-align: left;">Following the CIA's recommendations</h4><p style="text-align: left;">Since this is the CIA's general idea for command and control infrastructure, we might as well follow their recommendations for the implant. The CIA, alongside creating Switchblade, have a number of dos/donts for creating malware so as to avoid attribution and detection. These are great tips in general to make detection more difficult which is important in red team engagements. We've got to make sure our beacon traffic can't be replayed, the traffic is encrypted on the wire, the executable leaves a small footprint and is under 150kb, and that we obfuscate or encrypt any sensitive strings internally. There are others, but this is just a baseline. <br /></p><p style="text-align: left;">Right off the bat, we're not going to be able to keep any compiled Python based executable under 1000kb, let alone 150kb, so we'll have to look at other languages for that. We have ensured though that communication between the beacon and the server is encrypted and it can't be replayed either. This leaves sensitive strings, which certs could fall under. In my beacon example, I just pass the directory and file to read from. But in a deployable version, you will want to incorporate these into the program. In Python, this is a little tricky as the <span style="font-family: courier;">sslSettings.load_cert_chain</span> takes a cert file, not a variable with the cert as a string. So if you wanted to deploy this, you would need to deploy the cert file alongside - which is honestly an annoying short coming. How big of a deal this is depends on you. In Windows, we can add the certs to the cert chain and go from there, but the point is that we need to drop more than one file to make this work and you'll be expanding your footprint.<br /></p><h2 style="text-align: left;">Conclusion</h2><p style="text-align: left;">This was a pretty challenging project for me personally but I'm happy that I got the bare bones of it working the way I envisioned. I really want to get the PE version of the beacon setup so that I can do a mock red team exercise with a couple of Windows servers, server 2019 DC's, an ELK Security stack, and good ol' Windows Defender, but that's for the future. I think this provides a good base to build off of. If we look at a packet capture of this on the wire, we can see all the transmitted data is encrypted. Additionally, nothing can be replayed to the C2 server.<br /></p><h4 style="text-align: left;"></h4><p style="text-align: left;">I'm annoyed that I can't seem to find a way around dropping multiple certificates on the host, and yeah they can be hidden, but it's increasing the footprint we leave which increases the risk you have of being discovered. I believe the certificates required is the reason you don't often see this deployed out of specific circumstances. I hope to continue working on the client/server architecture for this so expect more in the future.<br /></p>